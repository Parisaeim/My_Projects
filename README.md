********Time Series Anomaly Detection using LSTM Autoencoder**********
This project implements Anomaly Detection on Time Series Data using an LSTM Autoencoder built with TensorFlow/Keras.
The model is trained to reconstruct normal weather patterns (temperature and pressure).
Anomalies are detected based on reconstruction error.

Project Pipeline:
Data preprocessing and feature selection
Scaling numerical features
Creating sliding window sequences
Building LSTM Autoencoder (Encoder-Decoder architecture)
Training with EarlyStopping
Calculating reconstruction error (MAE)
Setting anomaly threshold (99th percentile)
Visualizing detected anomalies over time

Model Architecture:
Encoder: LSTM(32)
Latent Representation
RepeatVector
Decoder: LSTM(32)
TimeDistributed Dense Output

Results:The model successfully identifies abnormal temperature patterns based on reconstruction error exceeding the defined threshold.  

*****Real-Time Smile Detection using CNN and OpenCV*****

This project implements a real-time smile detection system using a Convolutional Neural Network (CNN) built with TensorFlow/Keras and OpenCV for face detection.
The system detects faces in an image or webcam stream, extracts the facial region, and classifies it as Smiling or Not Smiling.
Features:
Face detection using Haar Cascade (OpenCV)
Custom CNN model for smile classification
Class imbalance handling using class weights
Real-time webcam smile detection
Model saving and loading (.keras format)
Evaluation using precision, recall, F1-score
Model Architecture:
The CNN architecture consists of:
3 Convolutional Blocks
Batch Normalization
MaxPooling Layers
Fully Connected Layer (128 neurons)
Dropout (0.5)
Sigmoid output for binary classification
Input shape: 96 × 96 × 3
Loss function: Binary Crossentropy
Optimizer: Adam
Dataset:Dataset used: Genki-4K (Smile Dataset)
Before training:
Face detection is applied
The largest detected face is cropped
Images are resized to 96×96
Pixel values are normalized to [0,1]
Handling Class Imbalance To prevent bias toward the majority class, class weights are computed using
During inference:
Webcam captures frame
Face is detected
Face region is cropped
Image is resized and normalized
Model predicts smile probability
Bounding box and label are displayed
Evaluation:
Model performance is evaluated using:
Accuracy
Precision
Recall
F1-score
Classification Report

*****Image Similarity Search using ResNet50 (PyTorch)****

This project implements a deep learning–based image similarity search system using a pretrained ResNet50 model.
Instead of training a classifier, the network is used as a feature extractor, and similarity is computed using Euclidean distance between feature vectors.
How It Works:
Step 1 — Extract Features for Dataset Images
Resize to 224×224
Normalize with ImageNet statistics
Pass through ResNet50
Save features in features.npy
Save image paths in Image_path.npy
Step 2 — Extract Features for Test Image Now we have a 2048-dimensional representation of the test image.
Step 3 — Compute Similarity Distance metric used
Similarity Formula Euclidean Distance
Smaller distance → higher similarity.
Before running similarity search, you must already have:
features.npy
Image_path.npy
These are generated by the feature extraction script.

*****Credit Prediction Using Regression****

This project predicts credit limit for bank customers
after several pre processing steps i used 3 layer MLP model and 81% accuracy

*****Image Steganography using LSB Matching (OpenCV & NumPy)*****

This project implements image steganography using the Least Significant Bit (LSB) Matching technique.
A secret image is hidden inside a host image by modifying the least significant bits of randomly selected pixels.
The same random seed is later used to extract the hidden image.
Method Used: LSB Matching
Technique: Least Significant Bit
Instead of directly replacing the LSB (like simple LSB replacement), this project uses LSB Matching:
If the pixel's LSB does not match the secret bit:
Increase or decrease pixel value by 1
Keep pixel within valid range [0,255]
This reduces statistical detectability compared to direct LSB replacement.
Step 1 — Load Images
Host image (e.g., 4K.jpg)
Secret image (run.jpg)
Step 2 — Convert Secret to Bits
Step 3 — Random Position Selection
Step 4 — LSB Matching
Step 5 — Save Stego Image
Extraction Process
Using the same seed:
Generate identical random positions
Extract LSB from those positions
Pack bits back to bytes
Reshape to original secret image

PARISA IMANI
